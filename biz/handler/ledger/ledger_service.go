// Code generated by hertz generator.

package ledger

import (
	"context"
	"errors"
	"log"
	"sort"
	"strconv"
	"strings"
	"time"

	ledger "universe/biz/model/ledger"
	dom "universe/domain/model"
	"universe/gdb"
	"universe/utils"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type listRow struct {
	id           uuid.UUID
	categoryId   uuid.UUID
	categoryName string
	amount       float64
	updatedAt    time.Time
}

func mergeRows(latest, since []listRow) map[uuid.UUID][]listRow {
	seen := make(map[uuid.UUID]struct{})
	grouped := make(map[uuid.UUID][]listRow)
	for _, r := range latest {
		if _, ok := seen[r.id]; !ok {
			seen[r.id] = struct{}{}
			grouped[r.categoryId] = append(grouped[r.categoryId], r)
		}
	}
	for _, r := range since {
		if _, ok := seen[r.id]; !ok {
			seen[r.id] = struct{}{}
			grouped[r.categoryId] = append(grouped[r.categoryId], r)
		}
	}
	return grouped
}

func toBizEntries(groups map[uuid.UUID][]listRow) []*ledger.LedgerEntry {
	var catIDs []uuid.UUID
	for k := range groups {
		catIDs = append(catIDs, k)
	}
	sort.Slice(catIDs, func(i, j int) bool { return catIDs[i].String() < catIDs[j].String() })
	var out []*ledger.LedgerEntry
	for _, cid := range catIDs {
		rows := groups[cid]
		sort.Slice(rows, func(i, j int) bool { return rows[i].updatedAt.After(rows[j].updatedAt) })
		for _, r := range rows {
			de := dom.LedgerEntry{Id: r.id, CategoryId: r.categoryId, Amount: r.amount, UpdatedAt: r.updatedAt}
			out = append(out, toBizEntryWithCategory(&de, r.categoryName))
		}
	}
	return out
}

func parseStartDate(s string) (*time.Time, error) {
	ss := strings.TrimSpace(s)
	if ss == "" {
		return nil, nil
	}
	ms, err := strconv.ParseInt(ss, 10, 64)
	if err != nil {
		return nil, err
	}
	t := time.UnixMilli(ms).UTC()
	return &t, nil
}

// CreateLedgerEntry .
// @router /v1/ledger/entries [POST]
func CreateLedgerEntry(ctx context.Context, c *app.RequestContext) {
	var err error
	var req ledger.CreateLedgerEntryReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// 参数验证：分类名称与金额
	categoryName := strings.TrimSpace(req.CategoryName)
	if categoryName == "" {
		utils.InvalidArgs(c, errors.New("分类名称不能为空"))
		return
	}
	if len(categoryName) > 255 {
		utils.InvalidArgs(c, errors.New("分类名称长度不能超过255"))
		return
	}

	db := gdb.GormDB()

	// 业务逻辑：检查分类是否已存在
	var existingCat dom.Category
	findErr := db.Where("name = ?", categoryName).First(&existingCat).Error
	if findErr == nil {
		// 分类已存在 → 业务错误
		utils.BizError(c, "分类已存在")
		return
	}
	if findErr != nil && findErr != gorm.ErrRecordNotFound {
		utils.InternalError(c, findErr)
		return
	}

	// 在同一事务中创建分类与账目
	var createdEntry dom.LedgerEntry
	txErr := db.Transaction(func(tx *gorm.DB) error {
		// 创建分类
		newCat := dom.Category{
			Id:   uuid.New(),
			Name: categoryName,
		}
		if err := tx.Create(&newCat).Error; err != nil {
			return err
		}

		// 创建关联的账目记录
		createdEntry = dom.LedgerEntry{
			Id:         uuid.New(),
			CategoryId: newCat.Id,
			Amount:     req.Amount,
			UpdatedAt:  time.Now().UTC(),
		}
		if err := tx.Create(&createdEntry).Error; err != nil {
			return err
		}
		return nil
	})
	if txErr != nil {
		utils.InternalError(c, txErr)
		return
	}

	// 返回创建的完整账目信息
	resp := new(ledger.CreateLedgerEntryRes)
	resp.Entry = toBizEntryWithCategory(&createdEntry, categoryName)
	utils.Success(c, resp)
}

// UpdateLedgerEntry .
// @router /v1/ledger/entries/update/:id [POST]
func UpdateLedgerEntry(ctx context.Context, c *app.RequestContext) {
	var err error
	var req ledger.UpdateLedgerEntryReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	if req.CategoryId == "" {
		utils.InvalidArgs(c, errors.New("分类ID为空"))
		return
	}

	db := gdb.GormDB()

	var category dom.Category
	catErr := db.First(&category, "id = ?", req.CategoryId).Error
	if catErr != nil {
		if catErr == gorm.ErrRecordNotFound {
			utils.BizError(c, "分类不存在")
		} else {
			utils.InternalError(c, catErr)
		}
		return
	}

	var resultEntry dom.LedgerEntry
	now := time.Now().UTC()
	startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.UTC)
	endOfDay := startOfDay.Add(24 * time.Hour)

	txErr := db.Transaction(func(tx *gorm.DB) error {
		if req.CategoryName != nil {
			newName := strings.TrimSpace(*req.CategoryName)
			if newName == "" || len(newName) > 255 {
				return errors.New("分类名称无效")
			}
			if err := tx.Model(&dom.Category{}).Where("id = ?", category.Id).Update("name", newName).Error; err != nil {
				log.Printf("update category name failed: %v", err)
				return err
			}
			category.Name = newName
		}

		var sameDayEntry dom.LedgerEntry
		dayErr := tx.Where("category_id = ? AND updated_at >= ? AND updated_at < ?", category.Id, startOfDay, endOfDay).Order("updated_at DESC").First(&sameDayEntry).Error
		if dayErr == nil {
			if req.Amount != nil {
				sameDayEntry.Amount = *req.Amount
			}
			sameDayEntry.UpdatedAt = now
			if err := tx.Save(&sameDayEntry).Error; err != nil {
				log.Printf("update ledger entry failed: %v", err)
				return err
			}
			resultEntry = sameDayEntry
			return nil
		}
		if dayErr != nil && dayErr != gorm.ErrRecordNotFound {
			log.Printf("query same-day ledger failed: %v", dayErr)
			return dayErr
		}

		if req.Amount == nil {
			log.Printf("only category name is updated while amount is nil")
			return nil
		}
		newEntry := dom.LedgerEntry{
			Id:         uuid.New(),
			CategoryId: category.Id,
			Amount:     *req.Amount,
			UpdatedAt:  now,
		}
		if err := tx.Create(&newEntry).Error; err != nil {
			log.Printf("create ledger entry failed: %v", err)
			return err
		}
		resultEntry = newEntry
		return nil
	})

	if txErr != nil {
		utils.InternalError(c, txErr)
		return
	}

	resp := new(ledger.UpdateLedgerEntryRes)
	resp.Entry = toBizEntryWithCategory(&resultEntry, category.Name)
	utils.Success(c, resp)
}

// DeleteLedgerEntry .
// @router /v1/ledger/entries/delete/:id [POST]
func DeleteLedgerEntry(ctx context.Context, c *app.RequestContext) {
	var err error
	var req ledger.DeleteLedgerEntryReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	if req.CategoryId == "" {
		utils.InvalidArgs(c, errors.New("分类ID不能为空"))
		return
	}

	db := gdb.GormDB()

	var category dom.Category
	catErr := db.First(&category, "id = ?", req.CategoryId).Error
	if catErr != nil {
		if catErr == gorm.ErrRecordNotFound {
			utils.BizError(c, "分类不存在")
		} else {
			utils.InternalError(c, catErr)
		}
		return
	}

	now := time.Now().UTC()
	startOfDay := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.UTC)
	endOfDay := startOfDay.Add(24 * time.Hour)

	txErr := db.Transaction(func(tx *gorm.DB) error {
		var sameDayEntry dom.LedgerEntry
		dayErr := tx.Where("category_id = ? AND updated_at >= ? AND updated_at < ?", category.Id, startOfDay, endOfDay).Order("updated_at DESC").First(&sameDayEntry).Error
		if dayErr == nil {
			sameDayEntry.Amount = 0
			sameDayEntry.UpdatedAt = now
			if err := tx.Save(&sameDayEntry).Error; err != nil {
				log.Printf("zero ledger entry amount failed: %v", err)
				return err
			}
			return nil
		}
		if dayErr != nil && dayErr != gorm.ErrRecordNotFound {
			log.Printf("query same-day ledger failed: %v", dayErr)
			return dayErr
		}

		newEntry := dom.LedgerEntry{
			Id:         uuid.New(),
			CategoryId: category.Id,
			Amount:     0,
			UpdatedAt:  now,
		}
		if err := tx.Create(&newEntry).Error; err != nil {
			log.Printf("create zero ledger entry failed: %v", err)
			return err
		}
		return nil
	})
	if txErr != nil {
		utils.InternalError(c, txErr)
		return
	}

	resp := new(ledger.DeleteLedgerEntryRes)
	utils.Success(c, resp)
}

// ListLedgerEntries .
// @router /v1/ledger/entries/list [POST]
func ListLedgerEntries(ctx context.Context, c *app.RequestContext) {
	var err error
	var req ledger.ListLedgerEntriesReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	var startPtr *time.Time
	if p, perr := parseStartDate(req.StartDate); perr != nil {
		utils.InvalidArgs(c, errors.New("start_date 需为 unix ms"))
		return
	} else {
		startPtr = p
	}

	type row struct {
		id           uuid.UUID
		categoryId   uuid.UUID
		categoryName string
		amount       float64
		updatedAt    time.Time
	}

	var latestRows []row
	var sinceRows []row

	pool := gdb.Postgres()
	q1 := "SELECT DISTINCT ON (le.category_id) le.id, le.category_id, c.name, le.amount, le.updated_at FROM ledger le JOIN ledger_category c ON c.id = le.category_id WHERE le.amount <> 0 ORDER BY le.category_id, le.updated_at DESC"
	rs1, qerr1 := utils.ExecuteQuery(ctx, pool, q1)
	if qerr1 != nil {
		utils.InternalError(c, qerr1)
		return
	}
	for rs1.Next() {
		var r row
		if err := rs1.Scan(&r.id, &r.categoryId, &r.categoryName, &r.amount, &r.updatedAt); err != nil {
			utils.InternalError(c, err)
			return
		}
		latestRows = append(latestRows, r)
	}
	rs1.Close()

	if startPtr != nil {
		q2 := "SELECT le.id, le.category_id, c.name, le.amount, le.updated_at FROM ledger le JOIN ledger_category c ON c.id = le.category_id WHERE le.updated_at >= $1 ORDER BY le.category_id, le.updated_at DESC"
		rs2, qerr2 := utils.ExecuteQuery(ctx, pool, q2, *startPtr)
		if qerr2 != nil {
			utils.InternalError(c, qerr2)
			return
		}
		for rs2.Next() {
			var r row
			if err := rs2.Scan(&r.id, &r.categoryId, &r.categoryName, &r.amount, &r.updatedAt); err != nil {
				utils.InternalError(c, err)
				return
			}
			sinceRows = append(sinceRows, r)
		}
		rs2.Close()
	}

	seen := make(map[uuid.UUID]struct{})
	grouped := make(map[uuid.UUID][]row)

	for _, r := range latestRows {
		if _, ok := seen[r.id]; !ok {
			seen[r.id] = struct{}{}
			grouped[r.categoryId] = append(grouped[r.categoryId], r)
		}
	}
	for _, r := range sinceRows {
		if _, ok := seen[r.id]; !ok {
			seen[r.id] = struct{}{}
			grouped[r.categoryId] = append(grouped[r.categoryId], r)
		}
	}

	var catIDs []uuid.UUID
	for k := range grouped {
		catIDs = append(catIDs, k)
	}
	sort.Slice(catIDs, func(i, j int) bool { return catIDs[i].String() < catIDs[j].String() })

	var out []*ledger.LedgerEntry
	for _, cid := range catIDs {
		rows := grouped[cid]
		sort.Slice(rows, func(i, j int) bool { return rows[i].updatedAt.After(rows[j].updatedAt) })
		for _, r := range rows {
			de := dom.LedgerEntry{Id: r.id, CategoryId: r.categoryId, Amount: r.amount, UpdatedAt: r.updatedAt}
			out = append(out, toBizEntryWithCategory(&de, r.categoryName))
		}
	}

	resp := new(ledger.ListLedgerEntriesRes)
	resp.Entries = out
	utils.Success(c, resp)
}
