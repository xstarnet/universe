// Code generated by hertz generator.

package user

import (
	"context"
	crand "crypto/rand"
	"errors"
	"math/big"
	"os"
	"strconv"
	"time"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/golang-jwt/jwt/v5"

	user "universe/biz/model/user"
	"universe/gdb"
	"universe/utils"

	dom "universe/domain/model"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// JWT secret key (should be stored in environment variable in production)
var jwtSecret = []byte("")

func getJWTSecret() []byte {
	if len(jwtSecret) == 0 {
		jwtSecret = []byte(os.Getenv("jwt_secret_key"))
	}
	return jwtSecret
}

// CreateUser .
// @router /v1/users [POST]
func CreateUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.CreateUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Generate a unique ID for the user
	userID := uuid.New()

	// Create domain user object
	newUser := dom.User{
		Id:     userID,
		Name:   req.Name,
		Phone:  req.Phone,
		Avatar: req.Avatar,
	}

	// Save to database
	db := gdb.GormDB()
	result := db.Create(&newUser)
	if result.Error != nil {
		utils.InternalError(c, result.Error)
		return
	}

	// Prepare response
	resp := new(user.CreateUserRes)
	resp.User = toBizUser(&newUser)

	utils.Success(c, resp)
}

// UpdateUser .
// @router /v1/users/update/:id [POST]
func UpdateUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.UpdateUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Find existing user
	db := gdb.GormDB()
	var existingUser dom.User
	result := db.First(&existingUser, "id = ?", req.Id)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			utils.BizError(c, "未找到用户")
		} else {
			utils.InternalError(c, result.Error)
		}
		return
	}

	// Update user information
	if req.Name != nil {
		existingUser.Name = req.Name
	}
	if req.Phone != nil {
		existingUser.Phone = *req.Phone
	}
	if req.Avatar != nil {
		existingUser.Avatar = req.Avatar
	}

	// Save updated user
	result = db.Save(&existingUser)
	if result.Error != nil {
		utils.InternalError(c, result.Error)
		return
	}

	// Prepare response
	resp := new(user.UpdateUserRes)
	resp.User = toBizUser(&existingUser)

	utils.Success(c, resp)
}

// DeleteUser .
// @router /v1/users/delete/:id [POST]
func DeleteUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.DeleteUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Delete user from database
	db := gdb.GormDB()
	result := db.Delete(&dom.User{}, "id = ?", req.Id)
	if result.Error != nil {
		utils.InternalError(c, result.Error)
		return
	}

	// Check if any user was deleted
	if result.RowsAffected == 0 {
		utils.BizError(c, "用户不存在")
		return
	}

	// No content response
	c.Status(consts.StatusNoContent)
}

// GetUser .
// @router /v1/users/:id [GET]
func GetUser(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.GetUserReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Find user
	db := gdb.GormDB()
	var foundUser dom.User
	result := db.First(&foundUser, "id = ?", req.Id)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			utils.NotFound(c, "用户未找到")
		} else {
			utils.InternalError(c, result.Error)
		}
		return
	}

	// Prepare response
	resp := new(user.GetUserRes)
	resp.User = toBizUser(&foundUser)

	utils.Success(c, resp)
}

// ListUsers .
// @router /v1/users/list [POST]
func ListUsers(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.ListUsersReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Build query
	db := gdb.GormDB()
	var users []dom.User
	query := db.Model(&dom.User{})

	// Apply filters if provided
	if req.Name != nil && *req.Name != "" {
		query = query.Where("name LIKE ?", "%"+*req.Name+"%")
	}
	if req.Phone != nil {
		query = query.Where("phone = ?", *req.Phone)
	}

	// Count total users for pagination
	var total int64
	query.Count(&total)

	// Calculate offset and limit for pagination
	offset := (req.Page - 1) * req.PageSize
	limit := req.PageSize

	// Get users with pagination
	query.Offset(int(offset)).Limit(int(limit)).Find(&users)

	// Convert to slice of pointers
	userPointers := make([]*user.User, len(users))
	for i := range users {
		userPointers[i] = toBizUser(&users[i])
	}

	// Prepare response
	resp := new(user.ListUsersRes)
	resp.Total = int32(total)
	resp.Users = userPointers

	utils.Success(c, resp)
}

// SendSmsCode .
// @router /v1/users/sms_code [POST]
func SendSmsCode(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.SendSmsCodeReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	if !utils.ValidatePhone(req.Phone) {
		utils.InvalidArgs(c, errors.New("手机号格式不正确"))
		return
	}
	// Simple rate limit: 1 request per minute per phone
	redisClient := gdb.Redis()
	rateKey := "sms_rate_limit:" + req.Phone
	if exists, _ := redisClient.Exists(ctx, rateKey).Result(); exists > 0 {
		utils.TooManyRequests(c, "已发送过验证码，请稍后再试")
		return
	}

	// Generate a cryptographically secure 6-digit SMS code
	n, err := crand.Int(crand.Reader, big.NewInt(900000))
	if err != nil {
		utils.InternalError(c, err)
		return
	}
	smsCode := int(n.Int64()) + 100000
	smsCodeStr := strconv.Itoa(smsCode)

	// Store the SMS code in Redis with an expiry time of 5 minutes
	err = redisClient.Set(ctx, "sms_code:"+req.Phone, smsCodeStr, 5*time.Minute).Err()
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Send the SMS code using Aliyun SMS service
	sdkErr := utils.SendSMSCode(smsCodeStr, req.Phone)
	if sdkErr != nil {
		utils.InternalError(c, sdkErr)
		return
	}

	// Only set the rate limit key if the SMS code was sent successfully
	_ = redisClient.Set(ctx, rateKey, "1", time.Minute).Err()
	resp := new(user.SendSmsCodeRes)

	utils.Success(c, resp)
}

// Login .
// @router /v1/users/login [POST]
func Login(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.LoginReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Verify the SMS code from Redis
	redisClient := gdb.Redis()
	storedCode, err := redisClient.Get(ctx, "sms_code:"+req.Phone).Result()
	if err != nil {
		utils.Unauthorized(c, "验证码无效或已过期")
		return
	}

	if storedCode != req.SmsCode {
		utils.Unauthorized(c, "验证码无效")
		return
	}

	// Check if user exists in database
	db := gdb.GormDB()
	var existingUser dom.User
	result := db.First(&existingUser, "phone = ?", req.Phone)
	if result.Error != nil {
		if result.Error == gorm.ErrRecordNotFound {
			userID := uuid.New()
			newUser := dom.User{
				Id:    userID,
				Phone: req.Phone,
			}
			result = db.Create(&newUser)
			if result.Error != nil {
				utils.InternalError(c, result.Error)
				return
			}
			existingUser = newUser
		} else {
			utils.InternalError(c, result.Error)
			return
		}
	}

	// Delete the used SMS code from Redis
	redisClient.Del(ctx, "sms_code:"+req.Phone)

	// Ensure JWT secret is configured
	secret := getJWTSecret()
	if len(secret) == 0 {
		utils.InternalError(c, errors.New("JWT secret not configured"))
		return
	}

	// Generate JWT token with 15 minutes expiration
	expirationTime := time.Now().Add(15 * time.Minute)
	claims := &jwt.RegisteredClaims{
		ExpiresAt: jwt.NewNumericDate(expirationTime),
		Issuer:    "universe-api",
		Subject:   existingUser.Id.String(),
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	tokenString, err := token.SignedString(secret)
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Generate refresh token with 7 days expiration
	refreshExpirationTime := time.Now().Add(7 * 24 * time.Hour)
	refreshClaims := &jwt.RegisteredClaims{
		ExpiresAt: jwt.NewNumericDate(refreshExpirationTime),
		Issuer:    "universe-api",
		Subject:   existingUser.Id.String(),
	}

	refreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
	refreshTokenString, err := refreshToken.SignedString(secret)
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Store refresh token in Redis with 7 days expiration
	err = redisClient.Set(ctx, "refresh_token:"+existingUser.Id.String(), refreshTokenString, 7*24*time.Hour).Err()
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Prepare response
	resp := new(user.LoginRes)
	resp.Token = tokenString
	resp.RefreshToken = refreshTokenString
	expiresIn := int32(expirationTime.Unix() - time.Now().Unix())
	resp.ExpiresIn = &expiresIn

	utils.Success(c, resp)
}

// Logout .
// @router /v1/users/logout [POST]
func Logout(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.LogoutReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Extract user ID from token
	tokenString := req.Token
	// Remove "Bearer " prefix if present
	if len(tokenString) > 7 && tokenString[:7] == "Bearer " {
		tokenString = tokenString[7:]
	}

	// Parse the token to get claims
	claims := &jwt.RegisteredClaims{}
	_, err = jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return getJWTSecret(), nil
	}, jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Alg()}))
	if err != nil {
		// If token is invalid, still return OK status to prevent enumeration attacks
		c.Status(consts.StatusOK)
		return
	}

	// Delete refresh token from Redis
	redisClient := gdb.Redis()
	redisClient.Del(ctx, "refresh_token:"+claims.Subject)

	resp := new(user.LogoutRes)

	utils.Success(c, resp)
}

// RefreshToken .
// @router /v1/users/refresh_token [POST]
func RefreshToken(ctx context.Context, c *app.RequestContext) {
	var err error
	var req user.RefreshTokenReq
	err = c.BindAndValidate(&req)
	if err != nil {
		utils.InvalidArgs(c, err)
		return
	}

	// Parse and validate refresh token
	refreshClaims := &jwt.RegisteredClaims{}
	secret := getJWTSecret()
	if len(secret) == 0 {
		utils.InternalError(c, errors.New("未配置 JWT 密钥"))
		return
	}

	refreshToken, err := jwt.ParseWithClaims(req.RefreshToken, refreshClaims, func(token *jwt.Token) (interface{}, error) {
		return secret, nil
	}, jwt.WithValidMethods([]string{jwt.SigningMethodHS256.Alg()}))
	if err != nil || !refreshToken.Valid {
		utils.Unauthorized(c, "刷新令牌无效")
		return
	}

	// Check if refresh token exists in Redis
	redisClient := gdb.Redis()
	storedRefreshToken, err := redisClient.Get(ctx, "refresh_token:"+refreshClaims.Subject).Result()
	if err != nil || storedRefreshToken != req.RefreshToken {
		utils.Unauthorized(c, "刷新令牌无效")
		return
	}

	// Generate a new JWT token with 15 minutes expiration
	newExpirationTime := time.Now().Add(15 * time.Minute)
	newClaims := &jwt.RegisteredClaims{
		ExpiresAt: jwt.NewNumericDate(newExpirationTime),
		Issuer:    "universe-api",
		Subject:   refreshClaims.Subject,
	}

	newToken := jwt.NewWithClaims(jwt.SigningMethodHS256, newClaims)
	newTokenString, err := newToken.SignedString(secret)
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Generate a new refresh token with 7 days expiration
	newRefreshExpirationTime := time.Now().Add(7 * 24 * time.Hour)
	newRefreshClaims := &jwt.RegisteredClaims{
		ExpiresAt: jwt.NewNumericDate(newRefreshExpirationTime),
		Issuer:    "universe-api",
		Subject:   refreshClaims.Subject,
	}

	newRefreshToken := jwt.NewWithClaims(jwt.SigningMethodHS256, newRefreshClaims)
	newRefreshTokenString, err := newRefreshToken.SignedString(secret)
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Store new refresh token in Redis, overwriting the old one
	err = redisClient.Set(ctx, "refresh_token:"+refreshClaims.Subject, newRefreshTokenString, 7*24*time.Hour).Err()
	if err != nil {
		utils.InternalError(c, err)
		return
	}

	// Prepare response
	resp := new(user.RefreshTokenRes)
	resp.Token = newTokenString
	resp.RefreshToken = newRefreshTokenString
	expiresIn := int32(newExpirationTime.Unix() - time.Now().Unix())
	resp.ExpiresIn = &expiresIn

	utils.Success(c, resp)
}
